scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import IntUtils
library LiquiShareTracker

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
fun (msg1 : Message) =>
fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

(* Error events *)
type Error =
| CodeIsSender
| CodeInsufficientFunds
| CodeInsufficientAllowance
| CodeNotOwner

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeIsSender              => Int32 -1
      | CodeInsufficientFunds     => Int32 -2
      | CodeInsufficientAllowance => Int32 -3
      | CodeNotOwner              => Int32 -4
      end
    in
    { _exception : "Error"; code : result_code }

let zero = Uint128 0

(* map contract to nested map of nftid => address
assumes both zrc2 token address, and nft Id are unique
*)



(* map the byte strings to the totalsupply *)

(* Dummy user-defined ADT *)
type Unit =
| Unit

let get_val =
  fun (some_val: Option Uint128) =>
  match some_val with
  | Some val => val
  | None => zero
  end

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract LiquiShareTracker
(
  contract_owner: ByStr20,
  name : String,
  symbol: String,
  decimals: Uint32,
  init_supply : Uint128
)

(* Mutable fields *)
(*map unique nftid to nftshare FT address, and num of FT shares *)
field nftsharesaddress : Map Uint256 ByStr20 = Emp Uint256 ByStr20
field nftid_used : Map Uint256 Bool = Emp Uint256 Bool
field num_shares : Map Uint256 Uint128 = Emp Uint256 Uint128


field balances: Map ByStr20 Uint128
  = let emp_map = Emp ByStr20 Uint128 in
    builtin put emp_map contract_owner init_supply

field allowances: Map ByStr20 (Map ByStr20 Uint128)
  = Emp ByStr20 (Map ByStr20 Uint128)

(* keep track of tokens minted for a given NFT_ID - uint ID -> uint supply mapping *)
field tokens_minted: Map Uint128 Uint128
 = Emp Uint128 Uint128

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  is_owner = builtin eq contract_owner address;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsNotSender(address: ByStr20)
  is_sender = builtin eq _sender address;
  match is_sender with
  | True =>
    err = CodeIsSender;
    ThrowError err
  | False =>
  end
end

procedure AcceptNFT(from : ByStr20, token_id : Uint256)
  accept
 end



(* transfer NFT from _sender to this contract) *)
procedure LiqNFTdeposit(nftaddress: ByStr20, tokenid: Uint256)
    (*msg1 = { _tag : "SetApprove"; _amount : Uint128 0; _recipient : nftaddress; to : _this_address; token_id : tokenid};*)
    msg1 = { _tag : "TransferFrom"; _amount : Uint128 0; _recipient : nftaddress; to : _this_address; token_id : tokenid};
    (*msgs = two_msgs msg1 msg2;*)
    msgs = one_msg msg1;
    send msgs
  end

(* transfer ZRC2 shares from user to contract/ burn address, at time of redemption *)
procedure TransferZRC2(
  receiver : ByStr20,
  token_amount : Uint128,
  token_address : ByStr20
  )
  (*msg1 = { _tag : "IncreaseAllowance"; _amount : Uint128 0; _recipient: token_address; amount : token_amount; spender : _this_address };*)
  msg_to_token = {
    _tag : "TransferFrom";
    _recipient: token_address;
    _amount: zero;
    from: _sender;
    to: receiver;
    amount: token_amount
  };
  (*msgs = two_msgs msg1 msg_to_token;*)
  msgs = one_msg msg_to_token;

  send msgs
end


(* transfer NFT from this contract to _sender) *)
procedure LiqNFTredeem(nftaddress: ByStr20, tokenid: Uint256)
    reciever = _sender;
    msg1 = { _tag : "Transfer"; _recipient : nftaddress; _amount : Uint128 0; to : reciever; token_id : tokenid};
    msgs = one_msg msg1;
    send msgs
  end


(***************************************)
(*             Transitions             *)
(***************************************)

transition RecipientAcceptTransferFrom(from : ByStr20, token_id : Uint256, recipient : ByStr20)
    AcceptNFT from token_id
end

transition TransferFromSuccessCallBack(from : ByStr20, token_id : Uint256, recipient : ByStr20)
    AcceptNFT from token_id
end


(* link deposited NFT to N shares of a specified FT*)
transition Deposit_and_link(nfttokenAddress: ByStr20, tokenid: Uint256, numshares: Uint128, fractionalshare: ByStr20)
    recipient = _sender;
    num_shares[tokenid]:=numshares;
    LiqNFTdeposit nfttokenAddress tokenid;
    nftsharesaddress[tokenid]:=fractionalshare
  end

transition return_and_redeem(nfttokenAddress: ByStr20, tokenid: Uint256)
    recipient = _sender;
    (*AuthorizedBurnIfSufficientBalance recipient amount; *)
    (*zrc2 tokaddress for fractional shares *)
    tokaddress <- nftsharesaddress[tokenid];
    toksupply <- num_shares[tokenid];
    match toksupply with
    | Some v =>
      validtokens = v;
      match tokaddress with
      | Some z =>
          TransferZRC2 _this_address validtokens z;
          LiqNFTredeem nfttokenAddress tokenid
      | None =>
      validtokens = Uint128 0
      end
    | None =>
      validtokens = Uint128 0
    end
end
